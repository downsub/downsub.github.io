<html>
  <head>
    <meta charset='utf-8'/>
    <link rel="preconnect" href="https://fonts.gstatic.com"/>
    <link rel="preconnect" href="https://www.youtube.com"/>
    <title>Download captions</title>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300&display=swap" rel="stylesheet"/>
    <style>
      html {
        overflow-y: scroll;
      }

      body {
        font-family: 'Roboto', sans-serif;
        font-size: 30pt;
        display: grid;
        grid-template-rows: 2ex 1fr auto;
        height: 100%;
        margin: 0;
        transition: background-color 0.3s ease;
      }

      a {
        text-decoration: none;
        color: inherit;
      }

      main {
        display: grid;
        height: 100%;
        place-items: center;
        text-align: center;
      }

      body.start {
        background-color: #eee;
      }
      body.choose-lang {
        document.querySelector('.player').classList.add('not-ready');
        background-color: #aea;
      }

      form {
        color: #555;
        cursor: default;
        letter-spacing: 0.01em;
        padding-top: 2ex;
        padding-bottom: 2ex;
      }

      form input {
        font-size: 18pt;
        padding: 1ex 0.5em;
        margin: 0;
        border-radius: 15px;
        border-width: 1px;
        border-color: #ccc;
        border-style: solid;
        color: #444;
      }

      form input[type="text"]:-webkit-autofill::first-line {
        font-size: 18pt;
      }

      form input:focus,
      form input:hover {
        outline: none;
        border-color: #000;
      }

      form input::placeholder {
        color: #ddd;
      }

      form input[type="submit"] {
        background-color: #7cf;
        border-color: #88c;
        color: #448;
        padding: 1ex 1.25em;
      }

      form input[type="submit"]:focus,
      form input[type="submit"]:hover {
        border-color: #228;
      }

      form input[type="submit"]:focus {
        background-color: #6be;
      }

      footer {
        font-size: 18pt;
      }

      form {
        margin-top: -6ex;
      }
      .choose-lang .start-only {
        opacity: 0;
      }
      .start .choose-lang-only {
        opacity: 0;
      }

      ul {
        display: grid;
        font-size: 25pt;
        list-style-type: none;
        padding: 0;
      }
      li {
        display: grid;
        grid-template-columns: 6em auto minmax(0, 8em);
        padding: 1ex 0.5em;
        cursor: pointer;
        transition: background-color 0.1s ease;
      }
      .choose-lang li div[data-field="lang_code"] {
        color: #6a6;
      }
      .choose-lang li:hover {
        background: #cfc;
      }

      ul .template {
        display: none;
      }

      footer {
        font-size: 16pt;
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        color: #888;
      }
      .choose-lang .start-only {
        opacity: 0;
      }

      ul {
        display: grid;
        font-size: 25pt;
        list-style-type: none;
        padding: 0;
      }
      li {
        display: grid;
        grid-template-columns: 6em auto minmax(0, 8em);
        padding: 1ex 0.5em;
        cursor: pointer;
        transition: background-color 0.1s ease;
      }
      .choose-lang li div[data-field="lang_code"] {
        color: #6a6;
      }
      .choose-lang li:hover {
        background: #cfc;
      }

      ul .template {
        display: none;
      }

      footer {
        font-size: 16pt;
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        color: #888;
      }
      .choose-lang .start-only {
        opacity: 0;
      }

      ul {
        display: grid;
        font-size: 25pt;
        list-style-type: none;
        padding: 0;
      }
      li {
        display: grid;
        grid-template-columns: 6em auto minmax(0, 8em);
        padding: 1ex 0.5em;
        cursor: pointer;
        transition: background-color 0.1s ease;
      }
      .choose-lang li div[data-field="lang_code"] {
        color: #6a6;
      }
      .choose-lang li:hover {
        background: #cfc;
      }

      ul .template {
        display: none;
      }

      footer {
        font-size: 16pt;
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        color: #888;
      }
      .choose-lang .start-only {
        opacity: 0;
      }

      ul {
        display: grid;
        font-size: 25pt;
        list-style-type: none;
        padding: 0;
      }
      li {
        display: grid;
        grid-template-columns: 6em auto minmax(0, 8em);
        padding: 1ex 0.5em;
        cursor: pointer;
        transition: background-color 0.1s ease;
      }
      .choose-lang li div[data-field="lang_code"] {
        color: #6a6;
      }
      .choose-lang li:hover {
        background: #cfc;
      }

      ul .template {
        display: none;
      }

      footer {
        font-size: 16pt;
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        color: #888;
      }

      footer p:nth-child(2) {
        text-align: center;
      }

      .report-bug {
        margin-right: 1em;
        text-align: right;
      }

      .options {
        display: inline-flex;
        margin: 1ex 0.5em;
        font-size: 18pt;
      }
      .options label {
        padding: 1ex 0.5em;
        color: #888;
        background-color: #fff;
      }
      .options input {
        opacity: 0;
        width: 0;
        height: 0;
      }
      .options input + label {
        border: 1px solid;
        border-top-color: #ccc;
        border-bottom-color: #ccc;
        border-radius: 0;
        border-left: none;
        border-right: none;
      }
      .options input:first-child + label {
        border-top-left-radius: 15px;
        border-bottom-left-radius: 15px;
        border-left: 1px solid #ccc;
        padding-left: 0.75em;
      }
      .options input + label:last-child {
        border-top-right-radius: 15px;
        border-bottom-right-radius: 15px;
        border-right: 1px solid #ccc;
        padding-right: 0.75em;
      }
      .options input:checked + label {
        background-color: #aaa;
        color: #fff;
      }
      .options input:checked + label {
        border-color: #888;
      }
      .options input:focus + label {
        border-color: #444;
        border-left: 1px solid #444;
        margin-left: -1;
      }
      .options input:focus:first-child + label {
        margin-left: 0;
      }
      .options input:focus + label + input + label {
        border-left: 1px solid #444;
        margin-left: -1
      }
      .options:hover input + label {
        border-top-color: #000 !important;
        border-bottom-color: #000 !important;
      }
      .options:hover input:first-child + label {
        border-left-color: #000 !important;
      }
      .options:hover input + label:last-child {
        border-right-color: #000 !important;
      }

      .not-ready iframe {
        display: none;
      }

      .player {
        display: grid;
        place-items: center;
      }

      .player iframe {
        grid-area: 1 / 1 / 1 / 1;
      }

      .player #thumbnail {
        width: 400px;
        height: 225px;
        background-repeat: no-repeat;
        background-size: cover;
        /* 4:3 thumbnails will be cropped */
        background-position: center;
        opacity: 1;
        pointer-events: none;
        grid-area: 1 / 1 / 1 / 1;
        transition: opacity 0.5s ease;
        z-index: 0;
      }

      .player.ready:hover #thumbnail,
      .player.ready.playing #thumbnail {
        opacity: 0;
      }

    </style>
  </head>
  <body class="start">
    <header></header>
    <main>
      <div class="choose-lang-only player not-ready">
        <div id="player"></div>
        <div id="thumbnail"></div>
        <div class="controls">
          <!--<input type="range" min="1" max="100" value="1" class="slider">-->
        </div>
      </div>
      <form action="">
        <label>
          <p class="start-only">To download captions, enter a YouTube URL:</p>
          <input type="text" placeholder="https://youtu.be/dQw4w9WgXcQ" name="url" size=45>
        </label>
        <input type="submit" value="Check">
        <div>
          <div class="options">
            <input type="radio" name="format" value="srt" id="format-srt"><label for="format-srt">SRT</label>
            <input type="radio" name="format" value="txt" id="format-txt"><label for="format-txt">TXT</label>
            <input type="radio" name="format" value="vtt" id="format-vtt"><label for="format-vtt">VTT</label>
            <input type="radio" name="format" value="ttml" id="format-ttml"><label for="format-ttml">TTML</label>
            <!--<fieldset>
            <legend>YouTube</legend>
            <input type="radio" name="format" value="json3" id="format-json3"><label for="format-json3">JSON3</label>
            <input type="radio" name="format" value="srv3" id="format-srv3"><label for="format-srv3">SRV3</label>
            <input type="radio" name="format" value="srv2" id="format-srv2"><label for="format-srv2">SRV2</label>
            <input type="radio" name="format" value="srv1" id="format-srv1"><label for="format-srv1">SRV1</label>
            </fieldset>-->
          </div>
        </div>
        <ul class="download-only">
          <li class="template">
            <div data-field="lang_code"></div>
            <div data-field="lang_translated"></div>
            <div data-field="name"></div>
          </li>
        </ul>
      </form>
    </main>
    <footer>
      <p></p>
      <p class="start-only"><a href="asr/">Looking for auto-generated captions?</a></p>
      <p class="report-bug"><a href="https://github.com/downsub/downsub.github.io/issues">Report a bug</a></p>
    </footer>
    <script>
      (() => {
        const getId = (url) => {
          const res = [
            new RegExp('^(https?://)?youtu\\.be/(?<id>[A-Za-z0-9_-]+)'),
            new RegExp('^(https?://)?(www\\.|m.)?(youtube|googlevideo|youtube-nocookie)\\.com/(embed/|v/|.*\\?v=|.*\\&v=)(?<id>[A-Za-z0-9_-]+)'),
          ];
          for (const re of res) {
            const match = url.match(re);
            if (match) return match.groups.id;
          }
        };
        const getCaptionList = async (id) => {
          const url = `https://www.youtube.com/api/timedtext?v=${id}&type=list`;
          const resp = await fetch(url);
          const xml = await resp.text();
          const doc = new DOMParser().parseFromString(xml, 'application/xml');
          const captions = [];
          for (const track of doc.getElementsByTagName('track')) {
            const lang_code = track.getAttribute('lang_code');
            const name = track.getAttribute('name');
            const lang_translated = track.getAttribute('lang_translated');
            captions.push({lang_code, name, lang_translated});
          }
          return captions;
        }
        const clearUl = () => {
          const ul = document.querySelector('ul');
          for (const li of ul.querySelectorAll('li')) {
            if (!li.classList.contains('template')) ul.removeChild(li);
          }
        };
        const setState = (state) => {
            document.body.classList.remove('start');
            document.body.classList.remove('choose-lang');
            document.body.classList.add(state);
        }
        const error = (msg) => {
            clearUl();
            setState('start');
            setTimeout(() => alert(msg), 200);
            throw msg;
        };
        const setUrlParams = (params) => {
          const searchParams = new URL(document.location).searchParams;
          for (const k in params) {
            searchParams.set(k, params[k]);
          }
          history.pushState({}, '', '?' + searchParams);
        };
        const listCaptions = async () => {
          const url = document.querySelector('input[name="url"]').value.trim();
          if (!url) {
            clearUl();
            setState('start');
            setUrlParams({url});
            return;
          };

          const id = getId(url);
          if (!id) error('Could not recognise this as a YouTube URL');
          setUrlParams({url});
          const captions = await getCaptionList(id);
          if (!captions.length) error('Could not find any captions for this video');

          clearUl();
          setState('choose-lang');
          const ul = document.querySelector('ul');
          const template = ul.querySelector('li.template')
          window.currentYoutubeId = id;
          document.querySelector('#thumbnail').style.backgroundImage = `url(https://img.youtube.com/vi/${id}/maxresdefault.jpg),url(https://img.youtube.com/vi/${id}/hqdefault.jpg)`;
          loadVideo(id);
          for (const caption of captions) {
            const li = template.cloneNode(true);
            li.classList.remove('template');
            for (const div of li.getElementsByTagName('div')) {
              div.innerText = div.dataset.value = caption[div.dataset.field];
            }
            ul.appendChild(li);
          }
        };
        document.querySelector('.options').addEventListener('click', ({target}) => {
          if (!target.matches('input[name="format"]')) return;
          const format = document.querySelector('input[name="format"]:checked').value;
          setUrlParams({format});
        });
        document.querySelector('form').addEventListener('submit', (e) => {
          listCaptions();
          e.preventDefault();
          return false;
        });

        const getCaptions = async (id, lang_code, name, format) => {
          const url = `https://www.youtube.com/api/timedtext?v=${id}&name=${name}&lang=${lang_code}&fmt=${format}`;
          const resp = await fetch(url);
          return await resp.text();
        };
        const getTtmlText = (parent) => {
          let text = '';
          for (const node of parent.childNodes) {
            // TODO: styles? deduping of shadows? comments?
            if (node.nodeName == '#text') {
              text += node.data;
            } else if (node.nodeName == 'br') {
              text += '\n';
            } else if (node.nodeName == 'span') {
              text += getTtmlText(node);
            }
          }
          return text;
        }
        const parseTtml = (ttml) => {
            const doc = new DOMParser().parseFromString(ttml, 'application/xml');
            const cues = [];
            for (const cue of doc.querySelectorAll('tt > body > div > p')) {
              const begin = cue.getAttribute('begin');
              const end = cue.getAttribute('end');
              const text = getTtmlText(cue);
              cues.push({begin, end, text});
            }
            return cues;
        };
        const ttmlToSrt = (ttml) => {
            // TODO: inline formatting? regions? karaoke?
            const cues = parseTtml(ttml);
            const lines = [];
            let n = 1;
            /* Aegi parses '<b', '<i', etc as formatting, but doesn't escape when
             * exporting, so as the next best option, let's follow WebVTT's lead:
             * https://developer.mozilla.org/en-US/docs/Web/API/WebVTT_API#cue_payload */
            const escapeFormatting = (str) => str.replace(/[&<>]/g,
              tag => ({
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
              }[tag]));
            for (const cue of cues) {
              const begin = cue.begin.replace('.', ',');
              const end = cue.end.replace('.', ',');
              /* \u{200b} is a placeholder to keep from breaking to the next cue */
              const text = cue.text.replace('\n\n', '\n\u{200b}\n');
              //lines.push(`${n}`);
              lines.push(`${begin} --> ${end}`);
              lines.push(`${escapeFormatting(text)}`);
              lines.push(``);
              n += 1;
            }
            return lines.join('\n');
        }
        const ttmlToTxt = (ttml) => {
            const cues = parseTtml(ttml);
            const lines = [];
            for (const cue of cues) {
              lines.push(cue.text);
            }
            return lines.join('\n');
        }
        const getCaptionsInFormat = async (id, lang_code, name, format) => {
          if (format == 'srt') {
            const captions = await getCaptions(id, lang_code, name, 'ttml');
            return ttmlToSrt(captions);
          } else if (format == 'txt') {
            const captions = await getCaptions(id, lang_code, name, 'ttml');
            return ttmlToTxt(captions);
          }
          return getCaptions(id, lang_code, name, format);
        }
        document.querySelector('ul').addEventListener('click', async ({target}) => {
          const li = target.closest('li');
          const lang_code = li.querySelector('[data-field="lang_code"]').dataset.value;
          const name = li.querySelector('[data-field="name"]').dataset.value;
          const format = document.querySelector('input[name="format"]:checked').value;
          const id = window.currentYoutubeId;
          const captions = await getCaptionsInFormat(id, lang_code, name, format);
          const blob = new Blob([captions], { type: 'application/octet-stream' });
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          let title;
          if (document.querySelector('.player').classList.contains('ready')) {
            /* The browser should deal with invalid characters */
            title = ytPlayer.player.getVideoData().title;
          }
          if (!title) title = id;
          if (name) {
            a.download = `${title}.${name}.${format}`;
          } else {
            a.download = `${title}.${lang_code}.${format}`;
          }
          a.click();
        });

        document.querySelector('input[name="url"]').focus();
        const searchParams = new URL(document.location).searchParams;
        let format = searchParams.get('format');
        if (!format) format = 'srt';
        if (!format.match(/^[a-z0-9]+$/)) format = 'srt';
        document.querySelector('input[name="format"][value="' + format + '"]').checked = true;
        const url = searchParams.get('url');
        if (url) {
          document.querySelector('input[name="url"]').value = url;
          listCaptions();
        }
      })();
      const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
      const loadVideo = async (id) => {
        document.querySelector('.player').classList.remove('ready');
        document.querySelector('.player').classList.add('not-ready');

        await ytPlayer.load(id);
        if (false) {
          // Duration is only populated when we try to play
          await ytPlayer.play();
          await ytPlayer.pause();
          console.log(ytPlayer.player.getDuration());
        }
        ytPlayer.player.addEventListener('onStateChange', ({data}) => {
          document.querySelector('.player').classList.toggle('playing', data == YT.PlayerState.PLAYING);
        });
        document.querySelector('.player').classList.remove('not-ready');
        document.querySelector('.player').classList.add('ready');
      };

      class YtPlayerStateWaiter extends Promise {
        constructor(player, state) {
          let handlers;
          super((resolve, reject) => handlers = {resolve, reject});
          this._handlers = handlers;
          this._state = state;
          player.stateWaiters[state].push(new WeakRef(this));
        }
        static resolveAll(player, state, data) {
          for (const ref of player.stateWaiters[state]) {
            const waiter = ref.deref();
            if (waiter) waiter._handlers.resolve(data);
          }
        }
        static rejectAll(player, state, data) {
          for (const ref of player.stateWaiters[state]) {
            const waiter = ref.deref();
            if (waiter) waiter._handlers.reject(new Error(`Player error: ${data}`));
          }
        }
        static [Symbol.species] = Promise;
        [Symbol.toStringTag] = 'YtPlayerStateWaiter';
      }
      window.YtPlayerStateWaiter = YtPlayerStateWaiter;

      class YtPlayer {
        static apiReady = new Promise((resolve) => YtPlayer._apiReadyResolve = resolve);

        constructor(objectId) {
          this.objectId = objectId;
          this.stateWaiters = {};
          this.playerReady = new Promise((resolve) => {
            this._resolvePlayerReady = resolve;
          });
        }

        async create() {
           /* The player doesn't fetch video data when using videoId until play is called.
           * It does include the title, but not author, if used to create the iframe.
           * However, it fetches video data when using a playlist (which can be a videoId).
           * You can see this in effect by checking whether the title or author appears.
           * Calling playVideo on a player without a videoId will throw error 2.
           * This includes if you cuePlaylist and the video data hasn't been fetched yet.
           * await player.cued() after cueing a playlist to fix this. */
          await YtPlayer.apiReady;
          await this.createIframe();
        }

        createIframe() {
          if (this.player) return this.playerReady;
          /* A race setting the origin sometimes results in a postMessage error,
           * regardless of when we create it. Seems YT relies on setTimeout.*/
          /* https://earth.stanford.edu/ has embedOptOutDeprecation in ytcfg,
           * which is how they get .ytp-hide-info-bar (showinfo=0). As a workaround,
           * we overlay the thumbnail while the video is paused. If we want to wait
           * until the chrome's disappeared, await sleep(3000) after first play. */
          this.player = new YT.Player(this.objectId, {
            width: 400,
            height: 225,
            playerVars: {
              mute: 1,
              controls: 0,        /* hides channel branding */
              disablekb: 1,       /* no keyboard control */
              fs: 0,              /* no full-screen as there are no controls */
              modestbranding: 1,  /* doesn't seem to do anything */
              playsinline: 1,     /* only affects iOS */
              rel: 0,             /* only show channel videos at end */
              loop: 1,            /* only works with playlist */
              cc_load_policy: 3,  /* undocumented, disables captions */
            },
          });
          this.createListeners();
          return this.playerReady;
        }

        async load(videoId) {
          /* "Cue" a video. This replaces the current video. */
          await this.playerReady;
          /* We use a playlist to make loop work */
          await this.player.cuePlaylist(videoId);
          await this.cued();
        }

        async play() {
          /* Only errors will stop the video playing */
          // FIXME: reject if load() is called
          const state = this.player.getPlayerState();
          if (state == YT.PlayerState.PLAYING) return;
          this.player.playVideo();
          await this.playing();
        }

        async pause() {
          const state = this.player.getPlayerState();
          if (state == YT.PlayerState.PAUSED || state == YT.PlayerState.CUED) return;
          if (state != YT.PlayerState.PLAYING && state != YT.PlayerState.BUFFERING) return Promise.reject(new Error(`Cannot pause`));
          this.player.pauseVideo();
          await this.paused();
        }

        async livePause() {
          // Looks great, but pegs the CPU
          player.pauseTime = ytPlayer.player.getCurrentTime();
          await ytPlayer.play();
          player.pauseInterval = setInterval(() => ytPlayer.player.seekTo(player.pauseTime), 1000);
        }

        async mute() { this.player.mute(); }
        async unmute() { this.player.unmute(); }

        get iframe() {
          return this.player.getIframe();
        }

        createListeners() {
          for (const state in YtPlayer.playStates) {
            this.stateWaiters[state] = [];
          }

          /* One listener, to avoid races. We don't get subsequent events
           * if this doesn't return in time, so also defer it with a timer. */
          this.player.addEventListener('onStateChange', ({data}) => {
            console.log(`YtPlayer.onStateChange: ${data}`);
            setTimeout(() => {
              for (const state in YtPlayer.playStates) {
                if (data == YtPlayer.playStates[state]) {
                  YtPlayerStateWaiter.resolveAll(this, state, data);
                }
              }
              // TODO: reject playing if cued or ended (or unstarted?)
            }, 0);
          });

          this.player.addEventListener('onError', ({data}) => {
            console.log(`YtPlayer.onError: ${data}`);
            setTimeout(() => {
              // TODO: check if it affects cued too
              for (const state of ['playing', 'paused', 'buffering']) {
                YtPlayerStateWaiter.rejectAll(this, state, data);
              }
            }, 0);
          });
          this.pausedOrBuffering = () => Promise.race([this.paused(), this.buffering()]);
          for (const state in YtPlayer.playStates) {
            this[state] = () => new YtPlayerStateWaiter(this, state);
          }
          /* Only fires once, can't fail */
          this.player.addEventListener('onReady', this._resolvePlayerReady);
        }
        [Symbol.toStringTag] = 'YtPlayer';
      }
      window.onYouTubeIframeAPIReady = () => {
        YtPlayer.playStates = {
          'unstarted': -1,
          'ended': YT.PlayerState.ENDED,
          'playing': YT.PlayerState.PLAYING,
          'paused': YT.PlayerState.PAUSED,
          'buffering': YT.PlayerState.BUFFERING,
          'cued': YT.PlayerState.CUED,
        }
        YtPlayer._apiReadyResolve();
      };
      window.YtPlayer = YtPlayer;
      window.ytPlayer = new YtPlayer('player');
      window.ytPlayer.create();

      /*
      player.addEventListener('onPlaybackRateChange', ({data}) => {
        console.log(`onPlaybackRateChange: ${data}`);
      });
      player.addEventListener('onApiChange', ({data}) => {
        console.log(`onApiChange: ${data}`);
      });
      */
    </script>
    <script src="https://www.youtube.com/iframe_api"></script>
  </body>
</html>
